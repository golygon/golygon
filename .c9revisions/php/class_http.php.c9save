{"ts":1354845983789,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":true,"ts":1354845985908,"patch":[[{"diffs":[[1,"<?php\n/*\n* Filename.......: class_http.php\n* Author.........: Troy Wolf [troy@troywolf.com]\n* Last Modified..: Date: 2006/03/06 10:15:00\n* Description....: Screen-scraping class with caching. Includes image_cache.php\n                   companion script. Includes static methods to extract data\n                   out of HTML tables into arrays or XML. Now supports sending\n                   XML requests and custom verbs with support for making\n                   WebDAV requests to Microsoft Exchange Server.\n*/\n\nclass http {\n    var $log;\n    var $dir;\n    var $name;\n    var $filename;\n    var $url;\n    var $port;\n    var $verb;\n    var $status;\n    var $header;\n    var $body;\n    var $ttl;\n    var $headers;\n    var $postvars;\n    var $xmlrequest;\n    var $connect_timeout;\n    var $data_ts;\n    \n    /*\n    The class constructor. Configure defaults.\n    */ \n    function http() {\n        $this->log = \"New http() object instantiated.<br />\\n\";\n        \n        /*\n        Seconds to attempt socket connection before giving up.\n        */\n        $this->connect_timeout = 30; \n        \n        /*\n        Seconds to wait for stream to do its thing and return.\n        In my experience, if you do nothing, this defaults to 60 seconds.\n        Now here is the kicker--if you set this to 10 seconds and the request\n        actually takes 83 seconds, your script will sit and wait the entire 83\n        seconds before returning the failure! So I'm not sure what the real\n        point is. For example, if it takes 83 seconds and does in fact succeed,\n        but you had the timeout set at 60, you will return a failure even though\n        the communication worked. Point is, set this higher than anything you\n        think you'll need. Either way you have to wait!\n        */\n        $this->stream_timeout = 60;\n        \n        /*\n        Set the 'dir' property to the directory where you want to store the cached\n        content. I suggest a folder that is not web-accessible.\n        End this value with a \"/\".\n        */\n        $this->dir = realpath(\"./\").\"/\"; //Default to current dir.\n\n        $this->clean();               \n\n        return true;\n    }\n    \n    /*\n    fetch() method to get the content. fetch() will use 'ttl' property to\n    determine whether to get the content from the url or the cache.\n    */\n    function fetch($url=\"\", $ttl=0, $name=\"\", $user=\"\", $pwd=\"\", $verb=\"GET\") {\n        $this->log .= \"--------------------------------<br />fetch() called<br />\\n\";\n        $this->log .= \"url: \".$url.\"<br />\\n\";\n        $this->status = \"\";\n        $this->header = \"\";\n        $this->body = \"\";\n        if (!$url) {\n            $this->log .= \"OOPS: You need to pass a URL!<br />\";\n            return false;\n        }\n        $this->url = $url;\n        $this->ttl = $ttl;\n        $this->name = $name;\n        $need_to_save = false;\n        if ($this->ttl == \"0\") {\n            if (!$fh = $this->getFromUrl($url, $user, $pwd, $verb)) {\n                return false;\n            }\n        } else {\n            if (strlen(trim($this->name)) == 0) { $this->name = MD5($url); }\n            $this->filename = $this->dir.\"http_\".$this->name;\n            $this->log .= \"Filename: \".$this->filename.\"<br />\";\n            $this->getFile_ts();\n            if ($this->ttl == \"daily\") {\n                if (date('Y-m-d',$this->data_ts) != date('Y-m-d',time())) {\n                    $this->log .= \"cache has expired<br />\";\n                    if (!$fh = $this->getFromUrl($url, $user, $pwd, $verb)) {\n                        return false;\n                    }\n                    $need_to_save = true;\n                    if ($this->getFromUrl()) { return $this->saveToCache(); }\n                    } else {\n                        if (!$fh = $this->getFromCache()) {\n                        return false;\n                    }\n                }\n            } else {\n                if ((time() - $this->data_ts) >= $this->ttl) {\n                    $this->log .= \"cache has expired<br />\";\n                    if (!$fh = $this->getFromUrl($url, $user, $pwd, $verb)) {\n                        return false;\n                    }\n                    $need_to_save = true;\n                } else {\n                    if (!$fh = $this->getFromCache()) {\n                        return false;\n                    }\n                }\n            }\n        }\n        \n        /*\n        Get response header.\n        */\n        $this->header = fgets($fh, 1024);\n        $this->status = substr($this->header,9,3);\n        while ((trim($line = fgets($fh, 1024)) != \"\") && (!feof($fh))) {\n            $this->header .= $line;\n            if ($this->status==\"401\" and strpos($line,\"WWW-Authenticate: Basic realm=\\\"\")===0) {\n                fclose($fh);\n                $this->log .= \"Could not authenticate<br />\\n\";\n                return FALSE;\n            }\n        }\n        \n        /*\n        Get response body.\n        */\n        while (!feof($fh)) {\n            $this->body .= fgets($fh, 1024);\n        }\n        fclose($fh);\n        if ($need_to_save) { $this->saveToCache(); }\n        return $this->status;\n    }\n    \n    /*\n    PRIVATE getFromUrl() method to scrape content from url.\n    */\n    function getFromUrl($url, $user=\"\", $pwd=\"\", $verb=\"GET\") {\n        $this->log .= \"getFromUrl() called<br />\";\n        preg_match(\"~([a-z]*://)?([^:^/]*)(:([0-9]{1,5}))?(/.*)?~i\", $url, $parts);\n        $protocol = $parts[1];\n        $server = $parts[2];\n        $port = $parts[4];\n        $path = $parts[5];\n        if ($port == \"\") {\n            if (strtolower($protocol) == \"https://\") {\n                $port = \"443\";\n            } else {\n                $port = \"80\";\n            }\n        }\n\n        if ($path == \"\") { $path = \"/\"; }\n        \n        if (!$sock = @fsockopen(((strtolower($protocol) == \"https://\")?\"ssl://\":\"\").$server, $port, $errno, $errstr, $this->connect_timeout)) {\n            $this->log .= \"Could not open connection. Error \"\n                .$errno.\": \".$errstr.\"<br />\\n\";\n            return false;\n        }\n        \n        stream_set_timeout($sock, $this->stream_timeout);\n        \n        $this->headers[\"Host\"] = $server.\":\".$port;\n        \n        if ($user != \"\" && $pwd != \"\") {\n            $this->log .= \"Authentication will be attempted<br />\\n\";\n            $this->headers[\"Authorization\"] = \"Basic \".base64_encode($user.\":\".$pwd);\n        }\n        \n        if (count($this->postvars) > 0) {\n            $this->log .= \"Variables will be POSTed<br />\\n\";\n            $request = \"POST \".$path.\" HTTP/1.0\\r\\n\";\n            $post_string = \"\";\n            foreach ($this->postvars as $key=>$value) {\n                $post_string .= \"&\".urlencode($key).\"=\".urlencode($value);\n            }\n            $post_string = substr($post_string,1);\n            $this->headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\";\n            $this->headers[\"Content-Length\"] = strlen($post_string);\n        } elseif (strlen($this->xmlrequest) > 0) {\n            $this->log .= \"XML request will be sent<br />\\n\";\n            $request = $verb.\" \".$path.\" HTTP/1.0\\r\\n\";\n            $this->headers[\"Content-Length\"] = strlen($this->xmlrequest);\n        } else {\n            $request = $verb.\" \".$path.\" HTTP/1.0\\r\\n\";\n        }\n\n        #echo \"<br />request: \".$request;\n\n        \n        if (fwrite($sock, $request) === FALSE) {\n            fclose($sock);\n            $this->log .= \"Error writing request type to socket<br />\\n\";\n            return false;\n        }\n        \n        foreach ($this->headers as $key=>$value) {\n            if (fwrite($sock, $key.\": \".$value.\"\\r\\n\") === FALSE) {\n                fclose($sock);\n                $this->log .= \"Error writing headers to socket<br />\\n\";\n                return false;\n            }\n        }\n        \n        if (fwrite($sock, \"\\r\\n\") === FALSE) {\n            fclose($sock);\n            $this->log .= \"Error writing end-of-line to socket<br />\\n\";\n            return false;\n        }\n        \n        #echo \"<br />post_string: \".$post_string;\n        if (count($this->postvars) > 0) {\n            if (fwrite($sock, $post_string.\"\\r\\n\") === FALSE) {\n                fclose($sock);\n                $this->log .= \"Error writing POST string to socket<br />\\n\";\n                return false;\n            }\n        } elseif (strlen($this->xmlrequest) > 0) {\n            if (fwrite($sock, $this->xmlrequest.\"\\r\\n\") === FALSE) {\n                fclose($sock);\n                $this->log .= \"Error writing xml request string to socket<br />\\n\";\n                return false;\n            }\n        }\n        \n        return $sock;\n    }\n    \n    /*\n    PRIVATE clean() method to reset the instance back to mostly new state.\n    */\n    function clean()\n    {\n        $this->status = \"\";\n        $this->header = \"\";\n        $this->body = \"\";\n        $this->headers = array();\n        $this->postvars = array();\n        /*\n        Try to use user agent of the user making this request. If not available,\n        default to IE6.0 on WinXP, SP1.\n        */\n        if (isset($_SERVER['HTTP_USER_AGENT'])) {\n            $this->headers[\"User-Agent\"] = $_SERVER['HTTP_USER_AGENT'];\n        } else {\n            $this->headers[\"User-Agent\"] = \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)\";\n        }\n        \n        /*\n        Set referrer to the current script since in essence, it is the referring\n        page.\n        */\n        if (substr($_SERVER['SERVER_PROTOCOL'],0,5) == \"HTTPS\") {\n            $this->headers[\"Referer\"] = \"https://\".$_SERVER['HTTP_HOST'].$_SERVER['REQUEST_URI'];\n        } else {\n            $this->headers[\"Referer\"] = \"http://\".$_SERVER['HTTP_HOST'].$_SERVER['REQUEST_URI'];\n        }\n    }\n    \n    /*\n    PRIVATE getFromCache() method to retrieve content from cache file.\n    */\n    function getFromCache() {\n        $this->log .= \"getFromCache() called<br />\";\n        //create file pointer\n        if (!$fp=@fopen($this->filename,\"r\")) {\n            $this->log .= \"Could not open \".$this->filename.\"<br />\";\n            return false;\n        }\n        return $fp;\n    }\n    \n    /*\n    PRIVATE saveToCache() method to save content to cache file.\n    */\n    function saveToCache() {\n        $this->log .= \"saveToCache() called<br />\";\n        \n        //create file pointer\n        if (!$fp=@fopen($this->filename,\"w\")) {\n            $this->log .= \"Could not open \".$this->filename.\"<br />\";\n            return false;\n        }\n        //write to file\n        if (!@fwrite($fp,$this->header.\"\\r\\n\".$this->body)) {\n            $this->log .= \"Could not write to \".$this->filename.\"<br />\";\n            fclose($fp);\n            return false;\n        }\n        //close file pointer\n        fclose($fp);\n        return true;\n    }\n    \n    /*\n    PRIVATE getFile_ts() method to get cache file modified date.\n    */\n    function getFile_ts() {\n        $this->log .= \"getFile_ts() called<br />\";\n        if (!file_exists($this->filename)) {\n            $this->data_ts = 0;\n            $this->log .= $this->filename.\" does not exist<br />\";\n            return false;\n        }\n        $this->data_ts = filemtime($this->filename);\n        return true;\n    }\n    \n    /*\n    Static method table_into_array()\n    Generic function to return data array from HTML table data\n    rawHTML: the page source\n    needle: optional string to start parsing source from\n    needle_within: 0 = needle is BEFORE table, 1 = needle is within table\n    allowed_tags: list of tags to NOT strip from data, e.g. \"<a><b>\"\n    */\n    function table_into_array($rawHTML,$needle=\"\",$needle_within=0,$allowed_tags=\"\") {\n        $upperHTML = strtoupper($rawHTML);\n        $idx = 0;\n        if (strlen($needle) > 0) {\n            $needle = strtoupper($needle);\n            $idx = strpos($upperHTML,$needle);\n            if ($idx === false) { return false; }\n            if ($needle_within == 1) {\n                $cnt = 0;\n                while(($cnt < 100) && (substr($upperHTML,$idx,6) != \"<TABLE\")) {\n                    $idx = strrpos(substr($upperHTML,0,$idx-1),\"<\");\n                    $cnt++;\n                }\n            }\n        }\n        $aryData = array();\n        $rowIdx = 0;\n        /*    If this table has a header row, it may use TD or TH, so \n        check special for this first row. */\n        $tmp = strpos($upperHTML,\"<TR\",$idx);\n        if ($tmp === false) { return false; }\n        $tmp2 = strpos($upperHTML,\"</TR>\",$tmp);\n        if ($tmp2 === false) { return false; }\n        $row = substr($rawHTML,$tmp,$tmp2-$tmp);\n        $pattern = \"/<TH>|<TH\\ |<TD>|<TD\\ /\";\n        preg_match($pattern,strtoupper($row),$matches);\n        $hdrTag = $matches[0];\n        \n        while ($tmp = strpos(strtoupper($row),$hdrTag) !== false) {\n            $tmp = strpos(strtoupper($row),\">\",$tmp);\n            if ($tmp === false) { return false; }\n            $tmp++;\n            $tmp2 = strpos(strtoupper($row),\"</T\");\n            $aryData[$rowIdx][] = trim(strip_tags(substr($row,$tmp,$tmp2-$tmp),$allowed_tags));\n            $row = substr($row,$tmp2+5);\n            preg_match($pattern,strtoupper($row),$matches);\n            $hdrTag = $matches[0];\n        }\n        $idx = strpos($upperHTML,\"</TR>\",$idx)+5;\n        $rowIdx++;\n        \n        /* Now parse the rest of the rows. */\n        $tmp = strpos($upperHTML,\"<TR\",$idx);\n        if ($tmp === false) { return false; }\n        $tmp2 = strpos($upperHTML,\"</TABLE>\",$idx);\n        if ($tmp2 === false) { return false; }\n        $table = substr($rawHTML,$tmp,$tmp2-$tmp);\n        \n        while ($tmp = strpos(strtoupper($table),\"<TR\") !== false) {\n            $tmp2 = strpos(strtoupper($table),\"</TR\");\n            if ($tmp2 === false) { return false; }\n            $row = substr($table,$tmp,$tmp2-$tmp);\n            \n            while ($tmp = strpos(strtoupper($row),\"<TD\") !== false) {\n            $tmp = strpos(strtoupper($row),\">\",$tmp);\n            if ($tmp === false) { return false; }\n            $tmp++;\n            $tmp2 = strpos(strtoupper($row),\"</TD\");\n            $aryData[$rowIdx][] = trim(strip_tags(substr($row,$tmp,$tmp2-$tmp),$allowed_tags));\n            $row = substr($row,$tmp2+5);\n            }\n            $table = substr($table,strpos(strtoupper($table),\"</TR>\")+5);\n            $rowIdx++;\n        }\n        return $aryData;\n    }\n    \n    /*\n    Static method table_into_xml()\n    Generic function to return xml dataset from HTML table data\n    rawHTML: the page source\n    needle: optional string to start parsing source from\n    allowedTags: list of tags to NOT strip from data, e.g. \"<a><b>\"\n    */\n    function table_into_xml($rawHTML,$needle=\"\",$needle_within=0,$allowedTags=\"\") {\n        if (!$aryTable = http::table_into_array($rawHTML,$needle,$needle_within,$allowedTags)) { return false; }\n        $xml = \"<?xml version=\\\"1.0\\\" standalone=\\\"yes\\\" \\?\\>\\n\";\n        $xml .= \"<TABLE>\\n\";\n        $rowIdx = 0;\n        foreach ($aryTable as $row) {\n            $xml .= \"\\t<ROW id=\\\"\".$rowIdx.\"\\\">\\n\";\n            $colIdx = 0;\n            foreach ($row as $col) {\n                $xml .= \"\\t\\t<COL id=\\\"\".$colIdx.\"\\\">\".trim(utf8_encode(htmlspecialchars($col))).\"</COL>\\n\";\n                $colIdx++;\n            }\n            $xml .= \"\\t</ROW>\\n\";\n            $rowIdx++;\n        }\n        $xml .= \"</TABLE>\";\n        return $xml;\n    }\n}\n\n?>"]],"start1":0,"start2":0,"length1":0,"length2":15320}]],"length":15320,"saved":false}
